import 'package:flutter/material.dart';
import 'dart:async';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: SafeArea(child: Scaffold(body: GameBoard())),
    );
  }
}

class GameBoard extends StatefulWidget {
  @override
  _GameBoardState createState() => _GameBoardState();
}

class _GameBoardState extends State<GameBoard> {
  List<List<String>> board = List.generate(3, (_) => List.generate(3, (_) => ""));
  List<List<double>> circleRadius =
      List.generate(3, (_) => List.generate(3, (_) => 0.0));
  List<List<double>> xProgress =
      List.generate(3, (_) => List.generate(3, (_) => 0.0));

  bool playerturn = false; // o = false, x = true
  String winner = "";
  List<Offset>? winLine; // จุดเริ่ม-สิ้นสุดเส้นผู้ชนะ
  double lineProgress = 0.0; // ความยาวเส้น (0 → 1)

  void _tabletap(TapDownDetails details, double tablewidth) {
    double cellSize = tablewidth / 3;
    int col = (details.localPosition.dx / cellSize).floor();
    int row = (details.localPosition.dy / cellSize).floor();

    if (row >= 0 &&
        row < 3 &&
        col >= 0 &&
        col < 3 &&
        board[row][col] == "" &&
        winner == "") {
      setState(() {
        board[row][col] = playerturn ? "X" : "O";
        if (board[row][col] == "O") {
          _growCircle(row, col, cellSize / 3);
        } else {
          _growX(row, col);
        }
        playerturn = !playerturn;
      });
    }
  }

  void _growCircle(int row, int col, double maxRadius) async {
    for (double r = 0; r <= maxRadius; r += 2) {
      await Future.delayed(Duration(milliseconds: 16));
      setState(() {
        circleRadius[row][col] = r;
      });
    }
  }

  void _growX(int row, int col) async {
    for (double p = 0; p <= 1.0; p += 0.05) {
      await Future.delayed(Duration(milliseconds: 16));
      setState(() {
        xProgress[row][col] = p;
      });
    }
  }

  String playerText(bool player) {
    return !playerturn ? "O" : "X";
  }

  String showWinner(List<List<String>> board, double size) {
    // row
    for (int i = 0; i < 3; i++) {
      if (board[i][0] != "" &&
          board[i][0] == board[i][1] &&
          board[i][1] == board[i][2]) {
        winLine = [
          Offset(0, i * size / 3 + size / 6),
          Offset(size, i * size / 3 + size / 6)
        ];
        _animateWinLine();
        return board[i][0];
      }
    }
    // col
    for (int j = 0; j < 3; j++) {
      if (board[0][j] != "" &&
          board[0][j] == board[1][j] &&
          board[1][j] == board[2][j]) {
        winLine = [
          Offset(j * size / 3 + size / 6, 0),
          Offset(j * size / 3 + size / 6, size)
        ];
        _animateWinLine();
        return board[0][j];
      }
    }
    // diag1
    if (board[0][0] != "" &&
        board[0][0] == board[1][1] &&
        board[1][1] == board[2][2]) {
      winLine = [Offset(0, 0), Offset(size, size)];
      _animateWinLine();
      return board[0][0];
    }
    // diag2
    if (board[0][2] != "" &&
        board[0][2] == board[1][1] &&
        board[1][1] == board[2][0]) {
      winLine = [Offset(size, 0), Offset(0, size)];
      _animateWinLine();
      return board[0][2];
    }
    // tie
    for (int k = 0; k < 3; k++) {
      for (int l = 0; l < 3; l++) {
        if (board[k][l] == "") return "";
      }
    }
    return "Tie";
  }

  void _animateWinLine() async {
    lineProgress = 0.0;
    for (double p = 0; p <= 1.0; p += 0.05) {
      await Future.delayed(Duration(milliseconds: 30));
      setState(() {
        lineProgress = p;
      });
    }
  }

  void clearboard() {
    setState(() {
      for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
          board[i][j] = "";
          circleRadius[i][j] = 0.0;
          xProgress[i][j] = 0.0;
        }
      }
      winner = "";
      winLine = null;
      lineProgress = 0.0;
      playerturn = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    double tableSize = MediaQuery.of(context).size.width;
    if (winner == "") winner = showWinner(board, tableSize);

    return MaterialApp(
      home: Scaffold(
        body: GestureDetector(
          onTapDown: (details) {
            if (winner == "") {
              _tabletap(details, tableSize);
            }
          },
          child: Column(
            children: [
              CustomPaint(
                size: Size(tableSize, tableSize),
                painter: oxtableline(board, circleRadius, xProgress, winLine, lineProgress),
              ),
              SizedBox(height: tableSize / 10),
              Text("Turn : ${playerText(playerturn)}",
                  style: TextStyle(fontSize: 28)),
              if (winner != "") ...[
                SizedBox(height: tableSize / 10),
                Text("Winner : $winner", style: TextStyle(fontSize: 28)),
                ElevatedButton(
                  onPressed: clearboard,
                  child: Text('Clear board',
                      style: TextStyle(fontSize: 28, color: Colors.black)),
                ),
              ]
            ],
          ),
        ),
      ),
    );
  }
}

class oxtableline extends CustomPainter {
  final List<List<String>> board;
  final List<List<double>> circleRadius;
  final List<List<double>> xProgress;
  final List<Offset>? winLine;
  final double lineProgress;

  oxtableline(this.board, this.circleRadius, this.xProgress, this.winLine, this.lineProgress);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.black87
      ..strokeWidth = 3;

    double widthmg = size.width / 3;
    double heightmg = size.height / 3;

    // Draw grid
    for (int i = 1; i < 3; i++) {
      canvas.drawLine(Offset(0, heightmg * i),
          Offset(size.width, heightmg * i), paint);
      canvas.drawLine(Offset(widthmg * i, 0),
          Offset(widthmg * i, size.height), paint);
    }

    // Draw O and X
    for (int row = 0; row < 3; row++) {
      for (int col = 0; col < 3; col++) {
        double cellSize = size.width / 3;
        if (board[row][col] == 'O') {
          final oPaint = Paint()
            ..color = Colors.blue
            ..style = PaintingStyle.stroke
            ..strokeWidth = 6;
          final center =
              Offset(col * cellSize + cellSize / 2, row * cellSize + cellSize / 2);
          canvas.drawCircle(center, circleRadius[row][col], oPaint);
        } else if (board[row][col] == 'X') {
          final xPaint = Paint()
            ..color = Colors.redAccent
            ..strokeCap = StrokeCap.round
            ..strokeWidth = 6;
          final left = col * cellSize;
          final top = row * cellSize;
          final right = left + cellSize;
          final bottom = top + cellSize;
          final gap = cellSize / 5;
          // ขีดตาม progress
          canvas.drawLine(
              Offset(left + gap, top + gap),
              Offset(left + gap + (right - left - 2 * gap) * xProgress[row][col],
                  top + gap + (bottom - top - 2 * gap) * xProgress[row][col]),
              xPaint);
          canvas.drawLine(
              Offset(right - gap, top + gap),
              Offset(right - gap - (right - left - 2 * gap) * xProgress[row][col],
                  top + gap + (bottom - top - 2 * gap) * xProgress[row][col]),
              xPaint);
        }
      }
    }

    // Draw winning line
    if (winLine != null) {
      final winPaint = Paint()
        ..color = Colors.green
        ..strokeWidth = 8
        ..strokeCap = StrokeCap.round;
      final dx = (winLine![1].dx - winLine![0].dx) * lineProgress;
      final dy = (winLine![1].dy - winLine![0].dy) * lineProgress;
      canvas.drawLine(winLine![0], Offset(winLine![0].dx + dx, winLine![0].dy + dy), winPaint);
    }
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => true;
}
